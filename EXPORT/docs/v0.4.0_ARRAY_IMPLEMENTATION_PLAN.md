# v0.4.0 Implementation Plan: Array Support with C-Spirit

## Philosophy

- Data-first design with plain structs
- One allocation strategy per subsystem
- Explicit error paths (no hidden exceptions in tight loops)
- Minimal templates (only for numeric kernels)
- Keep modules as .cpp + header + registration

## Core Array Type Design

### The Dense Array Structure

```cpp
// include/matlabcpp/array.hpp

namespace matlabcpp {

// Plain struct - data-first
struct ArrayData {
    double* data;           // Raw data buffer
    size_t* dims;           // Dimensions [rows, cols, ...]
    size_t* strides;        // Strides for layout
    size_t ndim;            // Number of dimensions (1D, 2D, 3D, ...)
    size_t size;            // Total element count
    int owns_data;          // 0 = view, 1 = owns buffer
};

// RAII wrapper for ownership (C++ safety)
class Array {
public:
    Array();                                // Empty array
    Array(size_t rows, size_t cols);        // 2D allocation
    Array(double* data, size_t* dims, size_t ndim);  // View constructor
    ~Array();
    
    // No copy (explicit only)
    Array(const Array&) = delete;
    Array& operator=(const Array&) = delete;
    
    // Move semantics (zero-copy)
    Array(Array&& other) noexcept;
    Array& operator=(Array&& other) noexcept;
    
    // Data access
    double* data() { return data_.data; }
    const double* data() const { return data_.data; }
    size_t size() const { return data_.size; }
    size_t ndim() const { return data_.ndim; }
    size_t dim(size_t i) const { return data_.dims[i]; }
    
    // Indexing
    double& operator()(size_t i);                // Linear A(k)
    double& operator()(size_t i, size_t j);      // 2D A(i,j)
    const double& operator()(size_t i) const;
    const double& operator()(size_t i, size_t j) const;
    
    // View creation (no copy)
    Array view() const;
    Array slice(size_t start, size_t end) const;
    
private:
    ArrayData data_;
    std::unique_ptr<double[]> buffer_;      // Owns data if owns_data=1
    std::unique_ptr<size_t[]> dims_buffer_; // Owns dims
    std::unique_ptr<size_t[]> strides_buffer_;
};

} // namespace matlabcpp
```

### Implementation Notes

**Allocation Strategy:**
- One contiguous buffer for data (double[] via unique_ptr)
- Separate dims/strides arrays
- Views use raw pointers with owns_data=0
- Column-major storage (MATLAB compatible)

**Memory Layout:**
```
2x3 matrix: [1 2 3; 4 5 6]
Memory: [1, 4, 2, 5, 3, 6]  (column-major)
dims: [2, 3]
strides: [1, 2]  (stride to next column = 2)
```

**No Fancy Features Yet:**
- No reference counting (explicit moves only)
- No dtype variants (double only)
- No complex numbers
- No sparse arrays

## Step 1: Array Type Implementation

### File: src/array.cpp

```cpp
#include "matlabcpp/array.hpp"
#include <cstring>
#include <stdexcept>

namespace matlabcpp {

Array::Array() {
    data_.data = nullptr;
    data_.dims = nullptr;
    data_.strides = nullptr;
    data_.ndim = 0;
    data_.size = 0;
    data_.owns_data = 0;
}

Array::Array(size_t rows, size_t cols) {
    data_.ndim = 2;
    data_.size = rows * cols;
    data_.owns_data = 1;
    
    // Allocate buffers
    buffer_ = std::make_unique<double[]>(data_.size);
    dims_buffer_ = std::make_unique<size_t[]>(2);
    strides_buffer_ = std::make_unique<size_t[]>(2);
    
    // Set pointers
    data_.data = buffer_.get();
    data_.dims = dims_buffer_.get();
    data_.strides = strides_buffer_.get();
    
    // Set dims and strides (column-major)
    data_.dims[0] = rows;
    data_.dims[1] = cols;
    data_.strides[0] = 1;
    data_.strides[1] = rows;
    
    // Initialize to zero
    std::memset(data_.data, 0, data_.size * sizeof(double));
}

Array::~Array() {
    // unique_ptr handles cleanup automatically
}

Array::Array(Array&& other) noexcept {
    data_ = other.data_;
    buffer_ = std::move(other.buffer_);
    dims_buffer_ = std::move(other.dims_buffer_);
    strides_buffer_ = std::move(other.strides_buffer_);
    
    // Clear other
    other.data_ = ArrayData{};
}

Array& Array::operator=(Array&& other) noexcept {
    if (this != &other) {
        data_ = other.data_;
        buffer_ = std::move(other.buffer_);
        dims_buffer_ = std::move(other.dims_buffer_);
        strides_buffer_ = std::move(other.strides_buffer_);
        other.data_ = ArrayData{};
    }
    return *this;
}

double& Array::operator()(size_t i) {
    if (i >= data_.size) {
        throw std::out_of_range("Linear index out of bounds");
    }
    return data_.data[i];
}

double& Array::operator()(size_t i, size_t j) {
    if (data_.ndim != 2) {
        throw std::runtime_error("2D indexing requires 2D array");
    }
    if (i >= data_.dims[0] || j >= data_.dims[1]) {
        throw std::out_of_range("Index out of bounds");
    }
    // Column-major: A(i,j) = data[j*rows + i]
    size_t idx = j * data_.strides[1] + i * data_.strides[0];
    return data_.data[idx];
}

// Const versions
const double& Array::operator()(size_t i) const {
    if (i >= data_.size) {
        throw std::out_of_range("Linear index out of bounds");
    }
    return data_.data[i];
}

const double& Array::operator()(size_t i, size_t j) const {
    if (data_.ndim != 2) {
        throw std::runtime_error("2D indexing requires 2D array");
    }
    if (i >= data_.dims[0] || j >= data_.dims[1]) {
        throw std::out_of_range("Index out of bounds");
    }
    size_t idx = j * data_.strides[1] + i * data_.strides[0];
    return data_.data[idx];
}

} // namespace matlabcpp
```

## Step 2: Matrix Literal Parsing

### Parser Enhancement

Add to lexer (or parser):
```cpp
// Recognize tokens
'['  -> LBRACKET
']'  -> RBRACKET
';'  -> SEMICOLON
','  -> COMMA (optional, treated like space)
```

### Parsing Rules

```
matrix_literal : '[' ']'                    // Empty []
               | '[' row_list ']'           // Rows
               ;

row_list : row
         | row_list ';' row
         ;

row : expr
    | row expr
    | row ',' expr
    ;
```

### Example Parses

```
[1 2 3]       -> 1x3 row vector
[1; 2; 3]     -> 3x1 column vector
[1 2; 3 4]    -> 2x2 matrix
[]            -> 0x0 empty
[1]           -> 1x1 scalar (or keep as scalar?)
```

### Implementation Sketch

```cpp
// In parser/evaluator
Variable parse_matrix_literal(TokenStream& tokens) {
    expect(LBRACKET);
    
    if (peek() == RBRACKET) {
        consume(RBRACKET);
        return Variable::empty_array();  // 0x0
    }
    
    std::vector<std::vector<double>> rows;
    
    while (true) {
        std::vector<double> row;
        
        // Parse elements in row
        while (peek() != SEMICOLON && peek() != RBRACKET) {
            Variable val = parse_expression();
            if (!val.is_scalar()) {
                error("Matrix literals must contain scalars");
            }
            row.push_back(val.as_scalar());
            
            if (peek() == COMMA) {
                consume(COMMA);  // Optional
            }
        }
        
        if (row.empty()) {
            error("Empty row in matrix literal");
        }
        
        rows.push_back(row);
        
        if (peek() == SEMICOLON) {
            consume(SEMICOLON);
            if (peek() == RBRACKET) break;  // Trailing semicolon
        } else {
            break;
        }
    }
    
    expect(RBRACKET);
    
    // Validate rectangular
    size_t cols = rows[0].size();
    for (const auto& row : rows) {
        if (row.size() != cols) {
            error("Matrix rows must have same length");
        }
    }
    
    // Build Array
    size_t nrows = rows.size();
    Array arr(nrows, cols);
    for (size_t i = 0; i < nrows; ++i) {
        for (size_t j = 0; j < cols; ++j) {
            arr(i, j) = rows[i][j];
        }
    }
    
    return Variable(std::move(arr));
}
```

## Step 3: Elementwise Operations

### Simple C-Style Loops

```cpp
// In array_ops.cpp

Array add_arrays(const Array& a, const Array& b) {
    // Shape check
    if (a.size() != b.size() || a.ndim() != b.ndim()) {
        throw std::runtime_error("Array dimensions must match");
    }
    for (size_t i = 0; i < a.ndim(); ++i) {
        if (a.dim(i) != b.dim(i)) {
            throw std::runtime_error("Array dimensions must match");
        }
    }
    
    // Allocate result
    Array result(a.dim(0), a.dim(1));  // 2D only for now
    
    // Tight loop
    const double* a_data = a.data();
    const double* b_data = b.data();
    double* r_data = result.data();
    size_t n = a.size();
    
    for (size_t i = 0; i < n; ++i) {
        r_data[i] = a_data[i] + b_data[i];
    }
    
    return result;
}

Array add_scalar(const Array& a, double s) {
    Array result(a.dim(0), a.dim(1));
    
    const double* a_data = a.data();
    double* r_data = result.data();
    size_t n = a.size();
    
    for (size_t i = 0; i < n; ++i) {
        r_data[i] = a_data[i] + s;
    }
    
    return result;
}

Array apply_sin(const Array& a) {
    Array result(a.dim(0), a.dim(1));
    
    const double* a_data = a.data();
    double* r_data = result.data();
    size_t n = a.size();
    
    for (size_t i = 0; i < n; ++i) {
        r_data[i] = std::sin(a_data[i]);
    }
    
    return result;
}
```

### Integration with Existing Functions

Modify evaluate_function_call():
```cpp
else if (func_name == "sin") {
    if (args.empty()) {
        throw std::runtime_error("sin() requires one argument");
    }
    const auto& var = args[0];
    
    if (var.is_scalar()) {
        return Variable(std::sin(var.as_scalar()));
    } else if (var.is_array()) {
        return Variable(apply_sin(var.as_array()));
    } else {
        throw std::runtime_error("sin() requires numeric input");
    }
}
```

## Step 4: Basic Indexing

### Syntax Support

```
A(k)       -> Linear indexing
A(i,j)     -> 2D indexing
A(:)       -> All elements as column vector
A(i,:)     -> Row i as row vector
A(:,j)     -> Column j as column vector
A(a:b)     -> Linear slice [a, a+1, ..., b]
A(a:b,j)   -> Rows a through b, column j
```

### Implementation Strategy

Add to parser:
```cpp
// Recognize indexing syntax
if (peek() == LPAREN && is_identifier()) {
    std::string name = consume_identifier();
    consume(LPAREN);
    
    std::vector<IndexExpr> indices = parse_index_list();
    
    consume(RPAREN);
    
    return evaluate_indexing(name, indices);
}
```

### Index Types

```cpp
struct IndexExpr {
    enum Type { SCALAR, COLON, RANGE } type;
    size_t scalar_val;
    size_t range_start;
    size_t range_end;
};

Variable evaluate_indexing(const std::string& name, 
                           const std::vector<IndexExpr>& indices) {
    Variable var = workspace_->get(name);
    
    if (!var.is_array()) {
        throw std::runtime_error("Cannot index non-array");
    }
    
    const Array& arr = var.as_array();
    
    // Linear indexing: A(k)
    if (indices.size() == 1 && indices[0].type == IndexExpr::SCALAR) {
        size_t k = indices[0].scalar_val;
        if (k < 1 || k > arr.size()) {  // 1-based
            throw std::out_of_range("Index out of bounds");
        }
        return Variable(arr(k - 1));  // Convert to 0-based
    }
    
    // 2D indexing: A(i,j)
    if (indices.size() == 2 && 
        indices[0].type == IndexExpr::SCALAR &&
        indices[1].type == IndexExpr::SCALAR) {
        size_t i = indices[0].scalar_val;
        size_t j = indices[1].scalar_val;
        if (i < 1 || i > arr.dim(0) || j < 1 || j > arr.dim(1)) {
            throw std::out_of_range("Index out of bounds");
        }
        return Variable(arr(i - 1, j - 1));  // Convert to 0-based
    }
    
    // TODO: Colon and range indexing
    
    throw std::runtime_error("Unsupported indexing pattern");
}
```

## Step 5: Constructor Functions

### zeros, ones, eye

```cpp
// In builtin_functions.cpp

Variable builtin_zeros(const std::vector<Variable>& args) {
    if (args.size() != 2) {
        throw std::runtime_error("zeros() requires 2 arguments: zeros(m,n)");
    }
    if (!args[0].is_scalar() || !args[1].is_scalar()) {
        throw std::runtime_error("zeros() arguments must be scalars");
    }
    
    size_t m = static_cast<size_t>(args[0].as_scalar());
    size_t n = static_cast<size_t>(args[1].as_scalar());
    
    Array arr(m, n);
    // Already initialized to zero in constructor
    return Variable(std::move(arr));
}

Variable builtin_ones(const std::vector<Variable>& args) {
    if (args.size() != 2) {
        throw std::runtime_error("ones() requires 2 arguments: ones(m,n)");
    }
    
    size_t m = static_cast<size_t>(args[0].as_scalar());
    size_t n = static_cast<size_t>(args[1].as_scalar());
    
    Array arr(m, n);
    double* data = arr.data();
    for (size_t i = 0; i < arr.size(); ++i) {
        data[i] = 1.0;
    }
    
    return Variable(std::move(arr));
}

Variable builtin_eye(const std::vector<Variable>& args) {
    if (args.size() != 1) {
        throw std::runtime_error("eye() requires 1 argument: eye(n)");
    }
    
    size_t n = static_cast<size_t>(args[0].as_scalar());
    
    Array arr(n, n);
    for (size_t i = 0; i < n; ++i) {
        arr(i, i) = 1.0;
    }
    
    return Variable(std::move(arr));
}

Variable builtin_linspace(const std::vector<Variable>& args) {
    if (args.size() != 3) {
        throw std::runtime_error("linspace() requires 3 arguments: linspace(a,b,n)");
    }
    
    double a = args[0].as_scalar();
    double b = args[1].as_scalar();
    size_t n = static_cast<size_t>(args[2].as_scalar());
    
    Array arr(1, n);  // Row vector
    
    if (n == 1) {
        arr(0, 0) = a;
    } else {
        double step = (b - a) / (n - 1);
        for (size_t i = 0; i < n; ++i) {
            arr(0, i) = a + i * step;
        }
    }
    
    return Variable(std::move(arr));
}
```

## Error Handling Strategy

### Explicit Result Type (C-Style Option)

```cpp
template<typename T>
struct Result {
    T value;
    const char* error;  // nullptr if success
    
    bool ok() const { return error == nullptr; }
};

Result<Array> add_arrays_checked(const Array& a, const Array& b) {
    if (a.size() != b.size()) {
        return {Array(), "Array dimensions must match"};
    }
    
    Array result(a.dim(0), a.dim(1));
    // ... perform operation
    
    return {std::move(result), nullptr};
}
```

### Exception-Based (Simpler for Now)

Keep using exceptions for user-facing errors:
- Bad syntax: throw std::runtime_error
- Out of bounds: throw std::out_of_range
- Type errors: throw std::runtime_error

Use Result<T> only in hot loops if needed for performance.

## Avoiding C++ Soup

### No Deep Hierarchies
```
BAD:
  Value
    -> NumericValue
       -> ScalarValue
       -> ArrayValue
          -> DenseArray
          -> SparseArray

GOOD:
  Variable (tagged union)
    - scalar: double
    - array: Array*
```

### No Template Metaprogramming
```
BAD:
  template<typename T, size_t N, typename Alloc, ...>
  class TensorImpl { ... }

GOOD:
  class Array {
    double* data;  // Just doubles for now
  }
```

### Keep Modules Simple
```
src/
  array.cpp          - Array implementation
  array_ops.cpp      - Elementwise operations
  constructors.cpp   - zeros, ones, eye, linspace
  indexing.cpp       - Indexing evaluation
```

## Integration with Existing Code

### Modify Variable Class

```cpp
class Variable {
public:
    enum Type { SCALAR, VECTOR, MATRIX, ARRAY };
    
    Variable(double s);
    Variable(Array arr);  // Add this
    
    bool is_array() const { return type_ == ARRAY; }
    const Array& as_array() const;
    Array& as_array();
    
private:
    Type type_;
    double scalar_;
    std::vector<double> vector_;
    std::vector<std::vector<double>> matrix_;
    std::unique_ptr<Array> array_;  // Add this
};
```

Deprecate VECTOR and MATRIX in favor of ARRAY eventually.

## Testing Strategy

### Unit Tests

```cpp
// tests/test_array.cpp

void test_array_construction() {
    Array arr(2, 3);
    assert(arr.size() == 6);
    assert(arr.dim(0) == 2);
    assert(arr.dim(1) == 3);
}

void test_array_indexing() {
    Array arr(2, 2);
    arr(0, 0) = 1.0;
    arr(0, 1) = 2.0;
    arr(1, 0) = 3.0;
    arr(1, 1) = 4.0;
    
    assert(arr(0) == 1.0);  // Linear, column-major
    assert(arr(1) == 3.0);
    assert(arr(2) == 2.0);
    assert(arr(3) == 4.0);
}

void test_elementwise_add() {
    Array a(2, 2);
    Array b(2, 2);
    
    a(0,0) = 1; a(0,1) = 2;
    a(1,0) = 3; a(1,1) = 4;
    
    b(0,0) = 10; b(0,1) = 20;
    b(1,0) = 30; b(1,1) = 40;
    
    Array c = add_arrays(a, b);
    
    assert(c(0,0) == 11);
    assert(c(0,1) == 22);
    assert(c(1,0) == 33);
    assert(c(1,1) == 44);
}
```

### Integration Tests

```matlab
% tests/test_arrays.m

A = [1 2 3]
assert(size(A) == [1 3])

B = [1; 2; 3]
assert(size(B) == [3 1])

C = [1 2; 3 4]
assert(C(1,1) == 1)
assert(C(2,2) == 4)

D = zeros(2,3)
assert(size(D) == [2 3])
assert(D(1,1) == 0)

E = ones(3,3)
assert(E(2,2) == 1)

F = eye(3)
assert(F(1,1) == 1)
assert(F(1,2) == 0)
```

## Performance Considerations

### Memory Locality
- Column-major ensures cache-friendly column access
- Contiguous buffer enables SIMD in future
- No pointer chasing (all data linear)

### Zero-Copy Views
- View constructor doesn't allocate
- Slicing returns views where possible
- Move semantics avoid copies

### Future SIMD
Structure allows easy SIMD:
```cpp
// Example (not for v0.4.0, just showing structure enables it)
for (size_t i = 0; i < n; i += 4) {
    __m256d a_vec = _mm256_load_pd(&a_data[i]);
    __m256d b_vec = _mm256_load_pd(&b_data[i]);
    __m256d c_vec = _mm256_add_pd(a_vec, b_vec);
    _mm256_store_pd(&c_data[i], c_vec);
}
```

## What We're NOT Doing (Yet)

- Multiple dtypes (int, float, complex)
- Sparse arrays
- GPU acceleration
- Broadcasting (scalar + array works, but not general broadcasting)
- Fancy indexing (logical, permutation)
- Reference counting
- Copy-on-write
- Lazy evaluation

These can come later if needed. Start simple.

## Implementation Order

1. Array class with 2D support (1 day)
2. Matrix literal parser (1 day)
3. zeros, ones, eye, linspace (4 hours)
4. Elementwise +, -, *, / for arrays (4 hours)
5. Elementwise math functions (sin, cos, etc.) (2 hours)
6. Basic indexing A(i,j) (4 hours)
7. Testing and debugging (1 day)

Total estimate: 4-5 days of focused work

## Success Criteria for v0.4.0

- Can create arrays: A = [1 2; 3 4]
- Can construct: zeros(m,n), ones(m,n), eye(n)
- Can index: A(i,j) returns element
- Can do elementwise: A + B, A + s, sin(A)
- Column-major storage verified
- No memory leaks (valgrind clean)
- MATLAB-compatible output format

## Documentation Updates Needed

- Update MATLAB_COMPATIBILITY.md with array support
- Add ARRAY_IMPLEMENTATION.md (this document)
- Update CHANGELOG.md for v0.4.0
- Add tests/manual_test_v0.4.0.txt

## The C-Spirit Checklist

- [ ] Plain struct for ArrayData
- [ ] RAII wrapper for safety
- [ ] One allocation strategy (contiguous buffer)
- [ ] Explicit ownership (owns_data flag)
- [ ] No template metaprogramming
- [ ] Simple tight loops for operations
- [ ] Clear error messages
- [ ] No hidden allocations in hot paths
- [ ] Move semantics for zero-copy
- [ ] Linear memory layout

This keeps the "feel" of C while using C++ for safety and convenience.
